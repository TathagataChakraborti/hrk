/*
* Compute the reward using performance metrics generated by Emotiv
* and log the reward through a socket client
*/

#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include<stdio.h>
#include<winsock2.h>

#pragma comment(lib,"ws2_32.lib") //Winsock Library

#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <cstdlib>
#include <stdexcept>
#include <string>
#include <math.h>

using namespace std;

#ifdef _WIN32
    #include <conio.h>
    #include <windows.h>
#endif
#ifdef __linux__
    #include <unistd.h>
#endif

#include "IEmoStateDLL.h"
#include "Iedk.h"
#include "IedkErrorCode.h"
#include "IEmoStatePerformanceMetric.h"

void CalculateScale(double& rawScore, double& maxScale,
                   double& minScale, double& scaledScore);

string logPerformanceMetricScore(unsigned int userID,
                               EmoStateHandle eState, bool withHeader = false);

#if __linux__ || __APPLE__
    #include <unistd.h>
    #include <termios.h>
    int _kbhit(void);
    int _getch( void );
#endif

int main(int argc, char** argv) {

	EmoEngineEventHandle eEvent			= IEE_EmoEngineEventCreate();
	EmoStateHandle eState				= IEE_EmoStateCreate();
	unsigned int userID					= 0;
	const unsigned short composerPort	= 1726;
	int option = 0;
	int state  = 0;
	std::string input;
	string ADDR_STRING = "0.0.0.0"; // Change the inet_address here
	string PORT_NUMBER = 8888;  // Change the port address here

	try {
        std::cout << "==================================================================="
                  << std::endl;
        std::cout << "Example to show how to log the EmoState from Emotiv Driver/"
                     "EmoComposer."
                  << std::endl;
        std::cout << "==================================================================="
                  << std::endl;
        std::cout << "Press '1' to start and connect to the Emotiv Driver "
                  << std::endl;
        std::cout << "Press '2' to connect to the EmoComposer  "
                  << std::endl;
		std::cout << ">> ";

		std::getline(std::cin, input, '\n');
		option = atoi(input.c_str());

		switch (option) {
        case 1:
            {
                if (IEE_EngineConnect() != EDK_OK)
                    throw std::runtime_error("Emotiv Insight Driver start up failed.");
                break;
            }
        case 2:
            {
                std::cout << "Target IP of EmoComposer? [127.0.0.1] ";
                std::getline(std::cin, input, '\n');

                if (input.empty()) {
                    input = std::string("127.0.0.1");
                }

                if (IEE_EngineRemoteConnect(input.c_str(), composerPort) != EDK_OK) {
                    std::string errMsg = "Cannot connect to EmoComposer on [" + input + "]";
                    throw std::runtime_error(errMsg.c_str());
                }
                break;
            }
        default:
            throw std::runtime_error("Invalid option...");
            break;
		}
		
		//-----------------------------------------

		WSADATA wsa;
		SOCKET s;
		struct sockaddr_in server;
		char *message;

		printf("\nInitialising Winsock...");
		if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		{
			printf("Failed. Error Code : %d", WSAGetLastError());
			return 1;
		}

		printf("Initialised.\n");

		//Create a socket
		if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
		{
			printf("Could not create socket : %d", WSAGetLastError());
		}

		printf("Socket created.\n");


		server.sin_addr.s_addr = inet_addr(ADDR_STRING);
		server.sin_family = AF_INET;
		server.sin_port = htons(PORT_NUMBER);

		//Connect to remote server
		if (connect(s, (struct sockaddr *)&server, sizeof(server)) < 0)
		{
			puts("connect error");
			return 1;
		}

		puts("Connected");
		
		// ----------------------------------------

        std::cout << "Start receiving PerformanceMetric Score! "
                  << "Press any key to stop logging..."
                  << std::endl;

		std::ofstream ofs("performanceMetricData.csv");
		bool writeHeader = true;

		while (!_kbhit()) {

			state = IEE_EngineGetNextEvent(eEvent);

			// New event needs to be handled
			if (state == EDK_OK) {
				
				IEE_Event_t eventType = IEE_EmoEngineEventGetType(eEvent);
				IEE_EmoEngineEventGetUserId(eEvent, &userID);

				// Log the EmoState if it has been updated
				if (eventType == IEE_EmoStateUpdated) {

					IEE_EmoEngineEventGetEmoState(eEvent, eState);
					const float timestamp = IS_GetTimeFromStart(eState);

					string message = "";
					message = logPerformanceMetricScore(userID, eState, writeHeader);
					const char *buffer = message.c_str();

					//-------------------------------------------------------------

					//Send some data

					if (send(s, buffer, strlen(buffer), 0) < 0)
					{
						puts("Send failed");
						return 1;
					}
					puts("Data Send\n");

					//-------------------------------------------------------------
					
					writeHeader = false;
				}
			}
			else if (state != EDK_NO_EVENT) {
				std::cout << "Internal error in Emotiv Engine!" << std::endl;
				break;
			}

#ifdef _WIN32
			Sleep(0.1);
#endif
#ifdef __linux__
            sleep(1);
#endif
		}


		closesocket(s);
		WSACleanup();

	}
    catch (const std::runtime_error& e) {
		std::cerr << e.what() << std::endl;
		std::cout << "Press any key to exit..." << std::endl;
		getchar();
	}

	IEE_EngineDisconnect();
	IEE_EmoStateFree(eState);
	IEE_EmoEngineEventFree(eEvent);

	return 0;
}


string logPerformanceMetricScore(unsigned int userID,
    EmoStateHandle eState, bool writeHeader) {

	std::string message = "y";

	// Log the time stamp and user ID
	string time = to_string(IS_GetTimeFromStart(eState));
	time = time.substr(0, 6);
	message +=  time + ",";
	
	// PerformanceMetric results
	double rawScore=0;
	double minScale=0;
	double maxScale=0;	
	double scaledScore=0;
	bool undefinedFlag = false;

    IS_PerformanceMetricGetStressModelParams(eState,&rawScore,&minScale,
                                             &maxScale);
	double stressScore = 0;

	if (minScale==maxScale)
	{
		 undefinedFlag = true;
	}
	else{
		CalculateScale(rawScore,maxScale, minScale,scaledScore);
		stressScore = scaledScore;
	}		

    IS_PerformanceMetricGetEngagementBoredomModelParams(eState,&rawScore,
                                                        &minScale,&maxScale);
	double engagementScore = 0;
	if (minScale==maxScale)
	{
		undefinedFlag = true;
	}
	else{
		CalculateScale(rawScore,maxScale, minScale,scaledScore);
		engagementScore = scaledScore;
	}	

    IS_PerformanceMetricGetRelaxationModelParams(eState,&rawScore,
                                                 &minScale,&maxScale);
	double relaxationScore = 0;
	if (minScale==maxScale)
	{
		undefinedFlag = true;
	}
	else{
		CalculateScale(rawScore,maxScale, minScale,scaledScore);
		relaxationScore = scaledScore;
	}	

    IS_PerformanceMetricGetInstantaneousExcitementModelParams(eState,
                                                              &rawScore,&minScale,
                                                              &maxScale);
	double excitementScore = 0;
	if (minScale==maxScale)
	{
		undefinedFlag = true;
	}
	else{
		CalculateScale(rawScore,maxScale, minScale,scaledScore);
		excitementScore = scaledScore;
	}

    IS_PerformanceMetricGetInterestModelParams(eState,&rawScore,
                                               &minScale,&maxScale);
	double interestScore = 0;
	if (minScale==maxScale)
	{
		undefinedFlag = true;
	}
	else{
		CalculateScale(rawScore,maxScale, minScale,scaledScore);
		interestScore = scaledScore;
	}
	
	float reward = 0;

	if (undefinedFlag)
		message += "xxxxxx";
	else
	{
		reward = engagementScore + interestScore + excitementScore - (3 * stressScore);
		string s_reward = to_string(reward);
		s_reward = s_reward.substr(0, 6);
		message += s_reward;
	}
	
	message += "z";
	return message;
}

void CalculateScale (double& rawScore, double& maxScale,
                    double& minScale, double& scaledScore){
	
	if (rawScore<minScale)
	{
		scaledScore =0;
	}else if (rawScore>maxScale)
	{
		scaledScore = 1;
	}
	else{
		scaledScore = (rawScore-minScale)/(maxScale-minScale);
	}
}

#ifdef __linux__
int _kbhit(void)
{
	struct timeval tv;
	fd_set read_fd;

	tv.tv_sec=0;
	tv.tv_usec=0;

	FD_ZERO(&read_fd);
	FD_SET(0,&read_fd);

	if(select(1, &read_fd,NULL, NULL, &tv) == -1)
		return 0;

	if(FD_ISSET(0,&read_fd))
		return 1;

	return 0;
}

int _getch(void)
{
	struct termios oldattr, newattr;
	int ch;

	tcgetattr(STDIN_FILENO, &oldattr);
	newattr = oldattr;
	newattr.c_lflag &= ~(ICANON | ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &newattr);
	ch = getchar();
	tcsetattr(STDIN_FILENO, TCSANOW, &oldattr);

	return ch;
}
#endif
#ifdef __APPLE__
int _kbhit(void)
{
	struct timeval tv;
	fd_set rdfs;

	tv.tv_sec = 0;
	tv.tv_usec = 0;

	FD_ZERO(&rdfs);
	FD_SET(STDIN_FILENO, &rdfs);

	select(STDIN_FILENO + 1, &rdfs, NULL, NULL, &tv);
	return FD_ISSET(STDIN_FILENO, &rdfs);
}

int _getch(void)
{
	int r;
	unsigned char c;
	if ((r = read(0, &c, sizeof(c))) < 0)
	{
		return r;
	}
	else
	{
		return c;
	}
}
#endif
